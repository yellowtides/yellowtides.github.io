<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://yellowtid.es/images/favicon.png" />
<title>Waiting List </title>
<meta name="title" content="Waiting List" />
<meta name="description" content="Waiting List [Hard; fb] Hack the Box CTF 2021 [Qualifiers]
 Your mechanical arm needs to be replaced. Unfortunately, Steamshake Inc which is the top mechanical arm transplants has a long waiting list. You have found a SQL injection vulnerability and recovered two tables from their database. Could you take advantage of the information in there to speed things up? Don&rsquo;t forget, you have a date on Monday!
 Proof of concept First, let us translate the given code into something more mathematical in order to try to model it." />
<meta name="keywords" content="" />


<meta property="og:title" content="Waiting List" />
<meta property="og:description" content="Waiting List [Hard; fb] Hack the Box CTF 2021 [Qualifiers]
 Your mechanical arm needs to be replaced. Unfortunately, Steamshake Inc which is the top mechanical arm transplants has a long waiting list. You have found a SQL injection vulnerability and recovered two tables from their database. Could you take advantage of the information in there to speed things up? Don&rsquo;t forget, you have a date on Monday!
 Proof of concept First, let us translate the given code into something more mathematical in order to try to model it." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://yellowtid.es/write-ups/htb-ctf-2021-quals/waiting-list/" /><meta property="article:section" content="write-ups" />
<meta property="article:published_time" content="2021-11-27T04:22:08+00:00" />
<meta property="article:modified_time" content="2021-11-27T04:22:08+00:00" /><meta property="og:site_name" content="Mathematics • Computer Science • Ideas" />




<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Waiting List"/>
<meta name="twitter:description" content="Waiting List [Hard; fb] Hack the Box CTF 2021 [Qualifiers]
 Your mechanical arm needs to be replaced. Unfortunately, Steamshake Inc which is the top mechanical arm transplants has a long waiting list. You have found a SQL injection vulnerability and recovered two tables from their database. Could you take advantage of the information in there to speed things up? Don&rsquo;t forget, you have a date on Monday!
 Proof of concept First, let us translate the given code into something more mathematical in order to try to model it."/>



<meta itemprop="name" content="Waiting List">
<meta itemprop="description" content="Waiting List [Hard; fb] Hack the Box CTF 2021 [Qualifiers]
 Your mechanical arm needs to be replaced. Unfortunately, Steamshake Inc which is the top mechanical arm transplants has a long waiting list. You have found a SQL injection vulnerability and recovered two tables from their database. Could you take advantage of the information in there to speed things up? Don&rsquo;t forget, you have a date on Monday!
 Proof of concept First, let us translate the given code into something more mathematical in order to try to model it."><meta itemprop="datePublished" content="2021-11-27T04:22:08+00:00" />
<meta itemprop="dateModified" content="2021-11-27T04:22:08+00:00" />
<meta itemprop="wordCount" content="1101">
<meta itemprop="keywords" content="" />
<meta name="referrer" content="no-referrer-when-downgrade" /><style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #262626;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

  code.has-jax {
    -webkit-font-smoothing: antialiased;
    background: inherit !important;
    border: none !important;
    font-size: 100%;
  }

</style>


  <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>
  <header><a href="../../../" class="title">
  <h2>Mathematics • Computer Science • Ideas</h2>
</a>
<nav><a href="../../../">Home</a>

<a href="../../../course-notes/">Course notes</a>

<a href="../../../self-study-notes/">Self-study notes</a>

<a href="../../../write-ups/">Write-ups</a>


<a href="../../../blog">Blog</a>

</nav>
</header>
  <main>
    
      
        

<content>
  <h2 id="waiting-list-hard-fb">Waiting List [Hard; fb]</h2>
<p><em>Hack the Box CTF 2021 [Qualifiers]</em></p>
<blockquote>
<p>Your mechanical arm needs to be replaced. Unfortunately, Steamshake Inc which is the top mechanical arm transplants has a long waiting list. You have found a SQL injection vulnerability and recovered two tables from their database. Could you take advantage of the information in there to speed things up? Don&rsquo;t forget, you have a date on Monday!</p>
</blockquote>
<h3 id="proof-of-concept">Proof of concept</h3>
<p>First, let us translate the given code into something more mathematical in order to try to model it. At the crux of the challenge lies the provided signing function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">P <span style="color:#f92672">=</span> <span style="color:#ae81ff">115792089210356248762697446949407573529996955224135760342422259061068512044369</span>
g <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
<span style="color:#75715e"># secret</span>
key <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>

sign(M):
    <span style="color:#75715e"># since 256 is the number of bits in P</span>
    h <span style="color:#f92672">=</span> MSB(SHA1(M), <span style="color:#ae81ff">256</span>)
    <span style="color:#75715e"># the nonce used in ECDSA</span>
    k <span style="color:#f92672">=</span> RAND(<span style="color:#ae81ff">1</span>, P<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    <span style="color:#75715e"># the calculation of r differs from standard ECDSA!</span>
    <span style="color:#75715e"># should raise some suspicions, as (*, Zmod(P)) is</span>
    <span style="color:#75715e"># usually a much weaker trapdoor than addition on</span>
    <span style="color:#75715e"># an EC, esp. since P-1 is relatively smooth</span>
    r <span style="color:#f92672">=</span> g<span style="color:#f92672">^</span>k (mod P)
    s <span style="color:#f92672">=</span> k<span style="color:#f92672">^</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> (h <span style="color:#f92672">+</span> key <span style="color:#f92672">*</span> r) (mod P)
    lsb <span style="color:#f92672">=</span> LSB(k, <span style="color:#ae81ff">7</span>)
    <span style="color:#66d9ef">return</span> h, r, s, lsb
</code></pre></div><p>So where and how is this actually used? Well, it seems to have been used on $200$ different appointments (provided to us in <code>appointments.txt</code>), the signatures of which (including <code>h</code> for convenience, and, more importantly, <code>lsb</code>) are provided to us in <code>signatures.txt</code>.</p>
<p>Providing the LSB of the nonce is something I&rsquo;ve never encountered in a textbook implementation of ECDSA (no wonder, since it serves 0 practical use), so this should immediately crank one&rsquo;s eyebrow height by a bit.</p>
<p>Experience dictates that I should try to write the modular equation on the 4th line of the signing function (<code>s = k^(-1) * (h + key * r) (mod P)</code>) using the given LSB, as it might decrease the maximum size of some of the hidden parameters. This, in turn, might lead to the famous ECDSA lattice attack on biased (small-sized) nonces being applicable (<a href="https://eprint.iacr.org/2019/023.pdf)">https://eprint.iacr.org/2019/023.pdf)</a>. The hidden number problem can very easily be exploited, so let&rsquo;s get to manipulating!</p>
<p>$$\begin{align}
s\equiv\,&amp;k^{-1} \cdot (h + key \cdot r) \pmod P
\\&amp;\iff s\cdot k \equiv h + key\cdot r \pmod P \\<br>
&amp;\iff s\cdot (u\cdot 2^7+lsb) \equiv h + key\cdot r \pmod P \\<br>
&amp;\iff s\cdot u\cdot128  \equiv  h + key\cdot r - s\cdot lsb \pmod P \\<br>
&amp;\iff u \equiv (128\cdot s)^{-1}(h-s\cdot lsb) + key\cdot r\cdot (128\cdot s)^{-1} \pmod P.
\end{align}$$</p>
<p>Where $u$ represents the unknown $256 - 7 = 249$ most significant bits of the nonce $k = u\cdot 2^7 + lsb$. Let&rsquo;s remind ourselves of the variables that we <strong>do not know</strong> in the equation above: $u$, and $key$.  Therefore, let $a \equiv -(128\cdot s)^{-1}(h-s\cdot lsb) \pmod P$ be a <strong>known</strong> constant, and let $t \equiv r\cdot (128\cdot s)^{-1} \pmod P$ be another <strong>known</strong> constant. Then, the equation above becomes</p>
<p>$$\begin{align*}
u \equiv\, &amp;(128\cdot s)^{-1}(h-s\cdot lsb) + key\cdot r\cdot (128\cdot s)^{-1} \pmod P \\<br>
&amp;\iff u \equiv -a + key\cdot t \pmod P
.\end{align*}$$</p>
<p>Or, by moving everything to the LHS, $$u - t\cdot key + a \equiv 0 \pmod P.$$</p>
<p>Again, we know that $u$ is $249$ bits long ($\approx B = 2^{249}$), $P$ is $256$ bits long, and that $a$ and $t$ are known. This means that the nonce $u$ is indeed biased by $7$ bits. We also have $200$ different plaintext/signature pairs, and hence $200$ equations of this form where the $key$ is constant throughout but the LSBs of the nonces $u$ can (and likely does) differ. Now, let us check with the requirements mentioned at the end of $4.1$ in <a href="https://eprint.iacr.org/2019/023.pdf">https://eprint.iacr.org/2019/023.pdf</a> to see if we can actually apply this attack. We do this with a little SageMath:</p>
<p><img src="waiting-list-check.png" alt=""></p>
<p>Aaaaand yep! We&rsquo;ve struck gold! $249 \leq 252$, and so we have just enough messages for the bias to make the attack feasible.</p>
<h3 id="the-attack">The attack</h3>
<p>Since the requirement mentioned above is met, all that&rsquo;s left to do is get to implementing the textbook LLL solution to the hidden number problem. For any one of the $200$ appointments $m_i$, assume the corresponding nonce $u_i$ and known parameters $$t_i \equiv r\cdot (128\cdot s)^{-1} \pmod P$$ and $$a_i \equiv -(128\cdot s)^{-1}(h-s\cdot lsb) \pmod P.$$ In other words, consider the relation that we deduced above:
$$u_i - t_i\cdot key + a_i \equiv 0 \pmod P.$$
As $\forall i$ the nonce $u_i$ shares the rough bit size of $B = 2^{249}$, we can go ahead and use the exact same lattice as the one in the paper:</p>
<p>$$M = \begin{bmatrix}
P \\<br>
&amp;P\\<br>
&amp;&amp;\ddots\\<br>
&amp;&amp;&amp;P&amp; &amp; \\<br>
t_1 &amp; t_2 &amp; &hellip; &amp; t_m &amp; B/P \\<br>
a_1 &amp; a_2 &amp; &hellip; &amp; a_m &amp; &amp; B
\end{bmatrix}$$</p>
<p>We expect the presence of a small vector of the form $(u_1, u_2. u_3, &hellip;, u_m, B\cdot key/p, B)$ inside of the LLL-reduced lattice. We push the LLL button on SageMath, and look for the rows that end in $B$. We look at the second-to-last entry, multiply by $P$, divide by $B$, and out should come the private key, at which point the scheme will be broken! <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>At that point, we can simply take the string <code>'william;yarmouth;22-11-2021;09:00'</code> that we want to forge the signature of, get the corresponding <code>h = MSB(SHA1(M), 256)</code>, and artificially set <code>k = 1</code>. With this, we can calculate the required signature $r = g^k = g = 5$, and $s \equiv k^{-1}(h + key \cdot r) \equiv h + key\cdot r \pmod P$. For us, this is</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;pt&#34;</span>: <span style="color:#e6db74">&#34;william;yarmouth;22-11-2021;09:00&#34;</span>,
 <span style="color:#f92672">&#34;r&#34;</span>: <span style="color:#e6db74">&#34;5&#34;</span>,
 <span style="color:#f92672">&#34;s&#34;</span>: <span style="color:#e6db74">&#34;367c299754595a06777081f3956e2da823cb57dd352f14e32ae6db7e5f335d84&#34;</span>}
</code></pre></div><p><strong>N.B.</strong> In practice, we might get multiple rows ending in $B$ in the final matrix. Hence, we construct a <em>set</em> of all the candidate private keys/second-to-last row entries. This isn&rsquo;t a major concern however, since we can expect this set to be really small (after all, the matrix has at most $200$ rows), so we can try the signatures that they would generate one at a time and see if they validate. For my solve script and the given problem data, the possible signatures  for <code>william;yarmouth;22-11-2021;09:00</code> (one per candidate private key) were</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{<span style="color:#f92672">&#34;pt&#34;</span>: <span style="color:#e6db74">&#34;william;yarmouth;22-11-2021;09:00&#34;</span>, <span style="color:#f92672">&#34;r&#34;</span>: <span style="color:#e6db74">&#34;5&#34;</span>, <span style="color:#f92672">&#34;s&#34;</span>: <span style="color:#e6db74">&#34;83edc3e7b414a270d03f027cd54d42fcc62ce44cc4cb3eff14395904b908ece8&#34;</span>}
{<span style="color:#f92672">&#34;pt&#34;</span>: <span style="color:#e6db74">&#34;william;yarmouth;22-11-2021;09:00&#34;</span>, <span style="color:#f92672">&#34;r&#34;</span>: <span style="color:#e6db74">&#34;5&#34;</span>, <span style="color:#f92672">&#34;s&#34;</span>: <span style="color:#e6db74">&#34;7bae5612ab4c6ad04080dc1f5102129368122c20e41b0d7df8943b1c61aa13ff&#34;</span>}
{<span style="color:#f92672">&#34;pt&#34;</span>: <span style="color:#e6db74">&#34;william;yarmouth;22-11-2021;09:00&#34;</span>, <span style="color:#f92672">&#34;r&#34;</span>: <span style="color:#e6db74">&#34;5&#34;</span>, <span style="color:#f92672">&#34;s&#34;</span>: <span style="color:#e6db74">&#34;367c299754595a06777081f3956e2da823cb57dd352f14e32ae6db7e5f335d84&#34;</span>}
{<span style="color:#f92672">&#34;pt&#34;</span>: <span style="color:#e6db74">&#34;william;yarmouth;22-11-2021;09:00&#34;</span>, <span style="color:#f92672">&#34;r&#34;</span>: <span style="color:#e6db74">&#34;5&#34;</span>, <span style="color:#f92672">&#34;s&#34;</span>: <span style="color:#e6db74">&#34;470d1190cdbedea4fed090cdc9107f6278b22ca2fedbc3a5189ebd8e6743c7a7&#34;</span>}
</code></pre></div><p>Since they was only $4$, I tried each of them by hand, one at a time. The third one verified successfully.</p>
<p><img src="waiting-list-flag.png" alt=""></p>
<p>Et voilà! First blood!</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><strong>N.B.</strong> In practice, what we get is the negative of the key, since our $(a_i)$ are negative by construction. We will need to negate this value to get the true private key.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

</content>
<p>
  
</p>

      
    
  </main>
  <footer>
</footer>

    
</body>

</html>
